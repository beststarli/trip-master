# 第三课JS/ES6/TS基础

## JavaScript

**ES6**：正式名称ECMAScript 2015，解决了ES5诸多痛点，为大型前端应用、全栈开发提供了语法支撑。引入了const声明常量、let声明变量。

**Atwood定律**：any application that can be written in JavaScript, will eventually be written in JavaScript。

**JavaScript应用领域**：
- Web：一直是使用JavaScript
- 小程序：ReactNative、Weex、Uniapp等实现跨平台开发
- 小程序；离不开JavaScript
- 桌面端：Electron
- 服务器端：Node.js
- 机器学习：TensorFlow.js、ONNX.js

**JavaScript为弱类型语言**：
- 隐式类型转换
- 类型检查发生在运行时
- 变量、属性、函数无静态签名束缚

**var存在的问题**：
- 只有“全局”和“函数”两级作用域，没有“块级”概念
- 变量提升，重复声明静默覆盖
- 循环闭包
- 全局对象污染

引入`let`来解决`var`的问题

**JavaScript的7个基本类型**：
- undefined：未定义，默认兜底值，声明但未赋值，`typeof`输出为`undefined`
- null：空对象引用，代码主动“清空”，typeof输出为`object`
- boolean：true/false
- number：IEEE-754双精度浮点值，包含`NaN`、`±Infinity`
- bigInt：任意大整数，后缀n，例如`123n`
- string：UTF-16字符串
- symbol：唯一且不可变标识，例如`Symbol('desc')`

```js
思考：可以赋值吗？

let obj
obj.name = 'Vintor' // 赋值操作不合法
```
**字符串String的属性/方法**：
- length：获取字符串长度
- indexOf()：返回字符串中指定文本***首次***出现的索引，找不到返回-1
- search()：搜索特定值的字符串并返回匹配的位置
- slice()：根据`start`和`end`截取字符串
- subString()：类似于`slice()`
- replace()：替换字符串中指定的值
- split()：分割字符串并转换为数组

```js
思考：parseFloat('335K')的值为多少？

parseFloat('335K')  // 335
```

`==`只匹配“值”，`===`既匹配“值”也匹配“类型” 

```js 
思考：123++和使用变量保存123然后++有什么区别？

123++   // 报错

let a = 123
a++     // 124
```

```js
思考：1 == true和1 === true有什么区别？

1 == true   // true，值匹配
1 === true  // false，值匹配，类型不匹配
```

**数组Array**：本质属于对象类型，动态、可变、起始索引为0
```js
const methods = ['string', 28, null, {a: 1}, [1, 2]]
```
数组的属性/方法：
- length：获取数组长度
- methods[index]：获取数组当前`index`下标的元素
- typeof：返回`object`
- Array.isArray(methods)：返回`true`
- push()：向数组添加元素
- pop()：删除最后一个元素，返回删除的元素
- join(',')：使用`,`将数组中元素拼接成字符串
- shift：删除第一个元素，返回删除的元素
- concat(['123'])：数组合并同时返回一个新数组，原数组不改变，浅拷贝
- sort()：根据元素首字母排序，可传入比值函数，如`sort((a,b) => a - b)`为升序排序
- forEach()：遍历数组
- map()：遍历数组并返回新的list
- filter()：根据规则返回满足条件的list
- every()：检查每个元素都满足条件
- some()：只需一个元素满足条件就返回true
- indexOf()：返回第一个符合条件的元素的下标，否则返回-1
- find()：返回第一个符合条件的元素

```js
数组迭代的5种方式：

for(let i = 0; i < methods.lenght; i++)  // 1.i为下标
for(let i in methods)                    // 2.i为下标
for(let method of methods)               // 3.method为元素
methods.forEach(method => {})            // 4.执行{}内方法，本身返回undefined
methods.map(method => {})                // 5.一一映射，本身返回新数组，原数组不变
```

```js
创建对象Object的方法：

// 方法1:
const p = new Object()
p.name = 'BestStar'
p.age = 23

// 方法2:
const p = {
    name: 'BestStar',
    age: 23
}

// 方法3:
const name = 'BestStar'
const age = 24
const p = {name, age}
```

**函数**：是一种**可调用的对象**（function object），用来封装一段可复用的逻辑

**类**：对已有的「构造函数 + 原型链」机制的语法糖封装。
- 类是带糖衣的构造函数
- 类体是批量忘原型挂方法
- 类字段帮助往构造函数中插入赋值语句

```js
ES6之前：

// 构造函数本体
function Point(x, y) {
    this.x = x
    this.y = y
}

// 原型方法
Point.prototype.show = function() {
    console.log(this.x, this.y)
}

// 建立对象 -> 链原型 -> 构造体内this指向它 -> 隐式返回该对象
new Point(0, 0)
```
ES6引入关键字`class`和`extends`

**this的作用**：
- 在函数执行时，动态引用当前函数的「执行上下文（运行环境）」中的对象
- 本质上是一个指向当前执行环境所属对象的指针（引用）。
- 让函数或对象能够灵活访问和操作其所属环境的对象属性/方法，实现代码复用与上下文关联。

```js
function sayHello(msg, info) {
    console.log(msg + ',' + this.name + info)
}

const p = {name: 'Vintor'}

// 1. call逐个传递参数，会自动执行
sayHello.call(p, 'Hello', '!')  // Hello,Vintor!

// 2. apply通过数组传递参数，会自动执行
sayHello.apply(p, ['Hi', '!!'])  // Hi,Vintor!!

// 3.bind逐个传递参数，返回新函数不会自动执行
const newSay = sayHello.bind(p, 'Hello', '!')
newSay()    // Hello,Vintor!
```