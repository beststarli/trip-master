# 第三课JS/ES6/TS基础

## JavaScript

### ES6
正式名称ECMAScript 2015，解决了ES5诸多痛点，为大型前端应用、全栈开发提供了语法支撑。引入了const声明常量、let声明变量。

### Atwood定律
any application that can be written in JavaScript, will eventually be written in JavaScript。

### JavaScript应用领域
- Web：一直是使用JavaScript
- 小程序：ReactNative、Weex、Uniapp等实现跨平台开发
- 小程序；离不开JavaScript
- 桌面端：Electron
- 服务器端：Node.js
- 机器学习：TensorFlow.js、ONNX.js

### JavaScript为弱类型语言
- 隐式类型转换
- 类型检查发生在运行时
- 变量、属性、函数无静态签名束缚

### var存在的问题
- 只有“全局”和“函数”两级作用域，没有“块级”概念
- 变量提升，重复声明静默覆盖
- 循环闭包
- 全局对象污染

引入`let`来解决`var`的问题

### JavaScript的7个基本类型
- undefined：未定义，默认兜底值，声明但未赋值，`typeof`输出为`undefined`
- null：空对象引用，代码主动“清空”，typeof输出为`object`
- boolean：true/false
- number：IEEE-754双精度浮点值，包含`NaN`、`±Infinity`
- bigInt：任意大整数，后缀n，例如`123n`
- string：UTF-16字符串
- symbol：唯一且不可变标识，例如`Symbol('desc')`

```js
思考：可以赋值吗？

let obj
obj.name = 'Vintor' // 赋值操作不合法
```

#### 字符串String的属性/方法
- length：获取字符串长度
- indexOf()：返回字符串中指定文本***首次***出现的索引，找不到返回-1
- search()：搜索特定值的字符串并返回匹配的位置
- slice()：根据`start`和`end`截取字符串
- subString()：类似于`slice()`
- replace()：替换字符串中指定的值
- split()：分割字符串并转换为数组

### 字符串与数值转换
```js
思考：parseFloat('335K')的值为多少？

parseFloat('335K')  // 335
```

`==`只匹配“值”，`===`既匹配“值”也匹配“类型” 

```js 
思考：123++和使用变量保存123然后++有什么区别？

123++   // 报错

let a = 123
a++     // 124
```

```js
思考：1 == true和1 === true有什么区别？

1 == true   // true，值匹配
1 === true  // false，值匹配，类型不匹配
```

### 数组Array
本质属于对象类型，动态、可变、起始索引为0
```js
const methods = ['string', 28, null, {a: 1}, [1, 2]]
```
数组的属性/方法：
- length：获取数组长度
- methods[index]：获取数组当前`index`下标的元素
- typeof：返回`object`
- Array.isArray(methods)：返回`true`
- push()：向数组添加元素
- pop()：删除最后一个元素，返回删除的元素
- join(',')：使用`,`将数组中元素拼接成字符串
- shift：删除第一个元素，返回删除的元素
- concat(['123'])：数组合并同时返回一个新数组，原数组不改变，浅拷贝
- sort()：根据元素首字母排序，可传入比值函数，如`sort((a,b) => a - b)`为升序排序
- forEach()：遍历数组
- map()：遍历数组并返回新的list
- filter()：根据规则返回满足条件的list
- every()：检查每个元素都满足条件
- some()：只需一个元素满足条件就返回true
- indexOf()：返回第一个符合条件的元素的下标，否则返回-1
- find()：返回第一个符合条件的元素

```js
数组迭代的5种方式：

for(let i = 0; i < methods.lenght; i++)  // 1.i为下标
for(let i in methods)                    // 2.i为下标
for(let method of methods)               // 3.method为元素
methods.forEach(method => {})            // 4.执行{}内方法，本身返回undefined
methods.map(method => {})                // 5.一一映射，本身返回新数组，原数组不变
```

### 对象
```js
创建对象Object的方法：

// 方法1:
const p = new Object()
p.name = 'BestStar'
p.age = 23

// 方法2:
const p = {
    name: 'BestStar',
    age: 23
}

// 方法3:
const name = 'BestStar'
const age = 24
const p = {name, age}
```

**函数**：是一种**可调用的对象**（function object），用来封装一段可复用的逻辑

**类**：对已有的「构造函数 + 原型链」机制的语法糖封装。
- 类是带糖衣的构造函数
- 类体是批量忘原型挂方法
- 类字段帮助往构造函数中插入赋值语句

```js
ES6之前：

// 构造函数本体
function Point(x, y) {
    this.x = x
    this.y = y
}

// 原型方法
Point.prototype.show = function() {
    console.log(this.x, this.y)
}

// 建立对象 -> 链原型 -> 构造体内this指向它 -> 隐式返回该对象
new Point(0, 0)
```
ES6引入关键字`class`和`extends`

### this的作用
- 在函数执行时，动态引用当前函数的「执行上下文（运行环境）」中的对象
- 本质上是一个指向当前执行环境所属对象的指针（引用）。
- 让函数或对象能够灵活访问和操作其所属环境的对象属性/方法，实现代码复用与上下文关联。

### call/apply/bind
```js
function sayHello(msg, info) {
    console.log(msg + ',' + this.name + info)
}

const p = {name: 'Vintor'}

// 1. call逐个传递参数，会自动执行
sayHello.call(p, 'Hello', '!')  // Hello,Vintor!

// 2. apply通过数组传递参数，会自动执行
sayHello.apply(p, ['Hi', '!!'])  // Hi,Vintor!!

// 3.bind逐个传递参数，返回新函数不会自动执行
const newSay = sayHello.bind(p, 'Hello', '!')
newSay()    // Hello,Vintor!
```
### switch case
**switch case**的判断逻辑为全等`===`

### 闭包
函数+函数声明时所在的词法作用域的引用。外层的函数执行完，其活动对象Activation Object本该被垃圾回收GC，但只要里层函数还存活并持有对外部变量的引用，活动对象就该被保留，形成**闭包**。
```js
示例：

function outer() {
    let count = 0   // 外层局部变量
    return function inner() {
        //里层函数被返回
        count++     // 依旧能访问count
        console.log(count)
    }
}

const inc = outer() // outer执行完，count本该消失
inc()   //1
inc()   //2
``` 

应用场景：
- 数据隐藏/私有变量（不暴露全局，只给指定借口）
- 函数工厂（按参数批量生成相似但独立的函数）
- 事件处理/异步回调（循环注册事件捕获当前索引）
- 偏函数&柯里化Currying（提前固化部分参数，延迟执行）
- 迭代器/生成器（维持迭代状态）
- 模块化（ES5时代）（模拟块级作用域，导出API）
- React Hooks（useState/useEffect闭包保存状态与最新props）

***闭包应谨慎使用，并且及时清理，避免内存泄漏***

### AJAX 异步的JavaScript和XML
2005年提出浏览器用JavaScript异步发送HTTP请求并处理响应

掌握请求生命周期、数据格式、跨域策略，就能让网页“无刷新”与服务器双向通信

XHR基于回调易陷入“回调地狱”，ES6之后可包裹为Promise
```js
const xhr = new XMLHttpRequest()            // 1.创建
xhr.open('GET', 'api/user?id=123', true)    // 2.初始化，true=异步
xhr.onreadystatechange = function() {       // 3.监听状态
    if (xhr.readyState === 4 && xhr.status === 200) {
        const data = JSON.parse(xhr.responseText)
        console.log(data)
    }
}

xhr.send()                                  //4.发送
```

现代替代：Fetch API（ES2017）
```js
fetch('/api/user', {method: 'GET', credentials: 'same-origin'})
    .then(res => {
        if (!res.ok) throw new Error(res.status)
        return res.json()   // 解析JSON
    })
    .then(user => console.log(user))
    .catch(err => console.error(err))
```

## ES6
### 解构赋值
从数组或对象中一次性提取值，直接按对应位置/名字塞入变量，不用再写临时变量或点语法
```js
数组解构赋值：

const [name1, name2] = ['Apple', 'Pear', 'Banana']
const [l, [m1, m2]] = [9, [8, 7]]   // l=9, m1=8, m2=7
```

```js
对象解构赋值：

const p = {name: 'BestStar', age: 23 }
const {sex = 'male'} = p || {}
```
> 对象解构右侧不能为`undefined`

### 展开运算符
```js
扩展运算符在左边，将剩余的数据打包到一个新的数组中：

const methods = ['PayMe', 'LinePay', 'Transfer']
const [ele, ...arr2] = methods
```
```js
扩展运算符在右边，解开数组中的数据：

const arr1 = ['PayMe', 'LinePay']
const arr2 = ['Transfer']
const methods = [...arr1, arr2]    // arr1不能是undefined
```
```js
作为函数形参，将传递的数据保存在1ist中：

function sum(...values) {}
function sum(a, ...values) {}
```
```js
扩展数据：

const p = {name: 'Vintor', sex: 'man'}
const info = {...p, age: 18}
```

### 箭头函数
```js
const getInfo = (name = 'BestStar') => {
    // ES6开始指定默认值
}
```
特征：
- 没有自己的`this`：永远捕获定义时外层作用域`this`
- 没有`arguments`对象：用剩余参数`...args`代替
- 没有`super`/ `new.target`：不能用作构造器
- 不能`new`：`new Arrow()`直接抛出TypeError
- 没有`prototype`属性：继承链更轻

### 类和对象
ES6之前没有“类”的语法，只有“构造函数+原型链”

ES6的`class`与`extends`、`super`、`static`、`constructor`、`私有#`只是把老机制包成语法糖

ES6的类 = 语法糖 + 严格模式 + 原生私有 + 简洁继承，底层依旧是`prototype链`

```js
class Info {
    private name
    private age
    
    constructor(name, age) {
        this.name = name
        this.age = age
    }

    getInfo() {
        static age = 23 //静态属性
        static pay() {} //静态方法
    }
}
```

### 继承
```js
ES6之前，原型链继承：

function Person(name, sex) {
    this.name = name
    this.sex = sex
    Person.prototype.eat = function() {}
}

function Worker(name, sex, time) {
    Person.call(this, name, sex)
    this.time = time
    this.worker = function() {}
}

// 子类原型设置为父类实例
Worker.prototype = new Person()
Worker.prototype.construtor = Worker

var worker = new Worker('BestStar', 'man', 23)
worker.eat()
```

```js
ES6之后：

class Person {
    constructor(name, sex) {
        this.name = name
        this.sex = sex
    }
    run() {}
}

class Worker extends Person {
    constructor(name, sex, time) {
        super(name, sex)
        this.time = time
    }
    worker() {}
}
```

### 修饰符/readonly/getter/setter
- **public**：共有属性/方法（默认）
- **private**：当前类中可见，私有属性/方法
- **protected**：当前类和子类中可见
- **readonly**：只读属性，不能给其赋值
- **get&set**：“访问器属性”（accessor property）的语法糖，用来把“读取/赋值”动作伪装成普通字段的样子，实则暗中执行函数

```js
class Circle {
    constructor(r) {
        this.r = r  // 真实字段
    }

    // 读取c.area时自动执行
    get area() {
        return Math.PI * this.r ** 2
    }

    // 赋值c.area = x时自动执行
    set area(value) {
        this.r = Math.sqrt(value / Math.PI)
    }
}

const c = new Circle(2)
console.log(c.area) // 12.566...
c.area = 50         // 写，set执行
console.log(c.r)    // 3.989...

```

## TypeScript