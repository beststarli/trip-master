# 第四课React/Next.js/H5中后台系统开发——个人记录

## React

### useState

#### 惰性初始化
只在组件首次渲染时执行一次
#### 函数式更新
setState为异步，该方式可以获取上一步的状态，在此基础上进行更新，解决因异步不能获取实时数据的问题

### useEffect
```tsx
useEffect(() => {

})
```
没有依赖数组，在每次组件更新都会执行

```tsx
useEffect(() => {

}, [])
```
空依赖数组，只在组件挂载时执行一次

### 同构
同构是指同一套代码即能在服务端运行，也能在客户端运行

同构组件设计原则：
- 避免在组件顶层使用浏览器API（window、document、localStorage）
- 将浏览器专属代码放在useEffect中
- 使用环境判断：typeof window !== 'undefined'
- 保证服务端和客户端初始渲染结果一致

#### SSR
SSR核心三步流程：
```tsx
第一步：服务端渲染

// 将React组件转换为HTML字符串
const html = ReactDOMServer.renderToString(<App />)
```

```tsx
第二步：嵌入模版返回

<div id='root'>${html}</div>
<script src='/bundle.js'></script>
```

```tsx
第三步：客户端水合

// 复用DOM，绑定事件，使页面可交互
hydrateRoot(document.getElementById('root'), <App />)
```

#### 水合
水合（Hydration）是指React在客户端“接管”服务端渲染的HTML的过程

```jsx
// 服务端渲染的HTML
<button class='btn'>点击</button>

// 水合后
<button class='btn'>点击</button>
```
水合做了什么：
- 遍历服务端渲染的DOM节点
- 与客户端虚拟DOM进行对比
- 复用已有DOM（不重新创建）
- 绑定事件处理器
- 执行useEffect副作用

## Next.js
### 高可用Web架构
![架构](/static/第四课/架构.png)

## 性能优化
### 性能指标FP/FCP/FMP
#### FP
First Paint，首次绘制。页面第一次出现“不同于空白页”的内容（比如背景色、文字轮廓）的时间点

#### FCP
First Contentful Paint，首次内容绘制。页面第一次出现“实际内容”（比如文本、图片）的时间点

#### FMP
First Meaning Paint，首次有效绘制。页面“核心内容”（比如主标题、商品列表）加载完成的时间点（用户能感受到“页面有用了”）

#### 提升FP/FCP方法
- 内联关键CSS，如：将首屏样式写在`<style>`里
- 延迟加载非首屏JS，如：用async/defer加载非核心内容

#### 提升FMP方法
- 优先加载核心内容，如：首屏接口提前请求
- 骨架屏占位，先展示骨架，再填充数据

### 瓶颈分析
通过“页面加载时序图" 定位性能卡点：
- 若domainLookup（DNS解析）耗时久——优化DNS（用CDN、预解析）
- 若response（接口响应）耗时久——优化接口/做数据缓存
- 若Processing（页面渲染）耗时久——优化JS执行、DOM渲染

#### 工具辅助
1. 用Chrome DevTools的【Performance】面板录制加载流程，看各阶段耗时
2. 用Lighthouse生成性能报告，定位具体卡点。

#### 链路拆解
按“DNS-TCP-接口-渲染”拆分流程，逐个阶段测耗时（比如用window.performance.timing读各阶段时间）。

### 无网/弱网优化
#### 针对网络差的场景
- 无网：提供“离线页面”（比如缓存历史数据展示）、断网提示
- 弱网：接口超时重试、资源降级（比如大图换小图）、请求队列管理（避免同时发太多请求）

#### 无网场景
- 用SerciceWorker缓存首页资源，断网时展示缓存页
- 本地存储用户常用数据（比如历史订单），无网时展示缓存数据

#### 弱网场景
- 接口设置阶梯超时（比如先等3S，重试再等5s）
- 资源降级（弱网下自动切换为低分辨率图片）
- 实现请求队列（弱网时把请求排队，网络恢复后批量发送）

### 资源加载与缓存
#### 优化静态资源（JS/CSS/ 图片）的加载效率
- 资源加载：压缩代码、图片格式优化（WebP）、CDN分发、懒加载（非首屏资源延迟加载）
- 缓存：利用HTTP缓存（强缓存/协商缓存）、ServiceWorker缓存（离线可用）、本地存储（localStorage存常用数据）

#### 资源加载
- 代码压缩：JS/CSS用Terser、CSSNano压缩，图片转WebP/AVIF
- CDN分发：静态资源部署到CDN，利用就近节点加速
- 懒加载：图片用loading="lazy”，组件用Reactlazy+Suspense延迟加载。

#### 缓存策略
- 强缓存：给静态资源设Cache-Control: max-age=31536000（一年）
- 协商缓存：资源文件名加哈希（比如app.xxx.js），更新时换哈希
- 离线缓存：用ServiceWorker缓存首屏资源

### 渲染/动画优化
#### 减少页面渲染耗时、避免卡顿：
- 渲染：減少DOM操作（用虚拟DOM）、避免重排重绘（比如用transform代替top/left）
- 动画：用CSS动画代替JS动画（CSS由浏览器渲染线程处理，更流畅）、开启硬件加速（will-change）

#### 渲染优化
- 减少DOM节点：避免嵌套过深、删除冗余节点
- 避免重排重绘：用documentFragment批量操作DOM，用transform/opacity代替width/top
- 开启分层：给动画元素加will-change:transform，让浏览器单独分层渲染

#### 动画优化
- 用CSS动画（@keyframes）代替JS动画
- 避免在动画中操作DOM/读取布局属性（比如offsetWidth）。

### 接口优化
#### 提升接口请求效率：
- 接口合并（多个请求合并为一个）、接口缓存（重复请求读缓存）、接口异步并行（非依赖的请求同时
发）；
- 数据压缩（接口返Gzip格式）、字段裁剪（只返回需要的字段）。

#### 请求效率
- 接口合并：多个独立接口合并为一个（比如“用户信息+订单列表”合并请求）
- 接口缓存：用Redis缓存高频接口（比如商品列表），设置合理过期时间
- 并行请求：非依赖接口用Promise.all同时发送（避免串行等待）

#### 数据传输
- 数据压缩：接口返回Gzip格式（后端开启压缩）
- 字段裁剪：接口只返回前端需要的字段（比如不用的createdAt不返回）

### 渲染方式
选择更高效的页面渲染方案：
- 服务端渲染（SSR）：首屏内容由后端渲染好再返回，提升FCP/FMP
- 预渲染：构建时提前渲染静态页面
- 同构渲染：一套代码同时支持 SSR 和客户端渲染

#### SSR（服务端渲染）
- 用Nextjs/Remix框架实现，首屏内容由后端渲染后返回
- 做SSR缓存（比如缓存首页渲染结果，5分钟更新一次）

#### 预渲染
用prerender-spa-plugin在构建时渲染静态页面（适合静态内容多的页面）

#### 同构渲染
一套代码同时支持SSR（首屏）和客户端渲染（交互），兼顾性能和体验

## H5中后台系统系统开发
### 中台系统技术方案
- [SSO单点登录](https://www.beststarli.cn/docs/Web%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AE%89%E5%85%A8/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95SSO)：单点登录的注意事项，鉴权如何做
- 通用权限管理：权限怎么做，角色如何管理
- 中间件
- 统一交互设计：中台交互设计规范，常用UI组件

#### 单点登录
- 概念：一次性鉴别登陆，获得关键系统权限
- 信息共享：办公系统由数百个子系统构成，如何共享？
- 安全性：认证系统生成加密凭证ticket交换信息

![SSO后端](/static/第四课/SSO后端.png)
> 后端视角

![SSO用户端](/static/第四课/SSO用户端.png)
> 用户端视角

缺点：
- 不利于重构：涉及系统多，重构需兼容所有系统，可能耗时长
- 无人看守桌面：因为只需登录一次，所有授权的应用系统都可以访问，可能导致信息泄漏

### 权限系统怎么设计
![权限分类](/static/第四课/权限分类.png)

#### 权限区分维度
- 功能维度：
    - 规则查看组：查看基础规则、查看业务线、查看变量、查看识别树、查看选择器
    - 修改规则组：修改基础规则、修改业务线、修改变量、修改识别树、修改选择器
    - TS支持组：选择器配置、流量查看、名单管理、事件配置、事件查询
- 岗位维度：
    - 客诉支持组：查看基础规则，流量直看、查看变量、事件查询
    - 售后服务组：修改基础规则、修改业务线、事件查询、名单管理
    - 策略配置组：选择器配置、选择器查看、业务线配置、业务线查看、识别树配置，识别树查看

#### 前端常用中间件
- 数据存储类：Redis、MySQL
- 配置管理类：qConfig
- 消息队列类：qmq、kafka
- 监控告警类：metric、cat
- 日志类：clog

注意点：
- 中间件在服务端运行
- 部分中间件如果要在客户端运行，需包装成一个http服务

### 交互设计
#### 中后台视觉体系布局系统
- 统一的画板尺寸
    - 主流分辨率为1920、1440、1366
    - 个别系统存在1280的显示设备
- 适配方案
    - 左右布局：常见为左侧导航栏固定，右侧工作区域动态缩放
    - 上下布局：两边留白区域进行最小值定义，留白区域达到限定值后再对中间主内容区动态缩放
- 栅格系统：Ant Design采用24栅格体系
    - 清晰定义动态区域范围
    - 关键数据的交付（Gutter、Column）
    - 区块的定义从column开始到column结束

#### Canvas和SVG对比
他们都是两大基于浏览器的渲染方案

##### 可扩展性：
- SVG是基于矢量的点、线、形状和数学公式来构建的图形，该图形是没有像素的，放大缩小不会失真。
- Canvas是由一个个像素点构成的图形，放大会使图形变得颗粒状和像素化（模糊）。

SVG可以在任何分辨率下以高质量的打印，Canvas不适合在任意分辦率下打印。

##### 渲染能力：
- 当SVG很复杂时，它的渲染就会变得很慢，因为在很大程度上去使用DOM时，渲染会变得很慢。
- Canvas提供了高性能的渲染和更快的图形处理能力，例如：适合制作H5小游戏。

当图像中具有大量元素时，SVG文件的大小会增长得更快
（导致DOM变得复杂），而Canvas并不会增加太多。
